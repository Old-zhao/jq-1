{"mappings":"AAAA,OAAO,IAAI,OAAO,SAAS,SAAU,eAAe;IAChD,IAAI;IACJ,gBAAgB;IAChB,IAAI,OAAO,oBAAoB,UAC3B,WAAW,SAAS,iBAAiB;SAGlC,IAAI,2BAA2B,OAClC,WAAW;IAGf,IAAI,MAAM;QACN,UAAS,SAAS;YACd,IAAK,IAAI,IAAI,GAAG,IAAI,SAAS,QAAQ,IACjC,QAAQ,CAAC,EAAE,CAAC,UAAU,IAAI;YAE9B,OAAO,IAAI,CAAE,0CAA0C;;QAC3D;QACA,MAAK,QAAQ;YACT,IAAI,QAAQ,EAAE;YACd,IAAK,IAAI,IAAI,GAAG,IAAI,SAAS,QAAQ,IACjC,QAAQ,MAAM,OAAO,MAAM,KAAK,QAAQ,CAAC,EAAE,CAAC,iBAAiB;YAEjE,wCAAwC;YACxC,MAAM,SAAS,IAAI,CAAE,OAAO;;YAC5B,kGAAkG;YAClG,2CAA2C;YAE3C,wDAAwD;YACxD,kFAAkF;YAClF,kCAAkC;YAClC,MAAM,SAAS,OAAO;YACtB,OAAO;QACX;QACA,OAAO;QACP,MAAK,EAAE;YACH,IAAK,IAAI,IAAI,GAAG,IAAI,SAAS,QAAQ,IACjC,GAAG,KAAK,MAAM,QAAQ,CAAC,EAAE,EAAE;YAE/B,OAAO,IAAI;QACf;QACA,SAAS;QACT;YACI,MAAM,QAAQ,EAAE;YAChB,IAAI,CAAC,KAAK,CAAC;gBACP,0BAA0B;gBAC1B,oBAAoB;gBACpB,IAAI,MAAM,QAAQ,KAAK,cAAc,GACjC,MAAM,KAAK,KAAK;YAExB;YACA,gDAAgD;YAChD,OAAO,OAAO;QAClB;QACA,SAAS;QACT;YACI,MAAM,QAAQ,EAAE;YAChB,mEAAmE;YACnE,IAAI,CAAC,KAAK,CAAC;gBAAW,MAAM,QAAQ,KAAK;YAAU;YACnD,gDAAgD;YAChD,OAAO,OAAO;QAClB;QACA,OAAO;QACP;YACI,MAAM,QAAQ,EAAE;YAChB,IAAI,CAAC,KAAK,CAAC;gBACP,UAAU;gBACV,MAAM,KAAK,KAAK;gBAChB,UAAU;gBACV,MAAM,KAAK,KAAK;YACpB;YACA,QAAQ,IAAI;QAChB;QACA,eAAe;QACf;YACI,QAAQ,IAAI;QAChB;QACA,+BAA+B;QAC/B,QAAQ,gBAAgB;QACxB,uBAAuB;QACvB;YACI,OAAO,IAAI,CAAC;QAChB;IACJ;IACA,OAAO;AACX,GAKI,kEAAkE;AAClE,uFAAuF;AAEvF,yCAAyC;AACzC,sCAAsC;AAEtC,qCAAqC;AACrC,EAAE,SAAS","sources":["jquery.js"],"sourcesContent":["window.$ = window.jQuery = function (selectorOrArray) {\n    let elements\n    // typeof 获取数据类型\n    if (typeof selectorOrArray === 'string') {\n        elements = document.querySelectorAll(selectorOrArray)\n        // instanceof 用来判断左侧对象是否是右侧构造函数的实例化对象\n        // 下面代码意思为selectorOrArray是否为数组，Array是构造数组的函数\n    } else if (selectorOrArray instanceof Array) {\n        elements = selectorOrArray\n    }\n\n    let api = {\n        addClass(className) {\n            for (let i = 0; i < elements.length; i++) {\n                elements[i].classList.add(className)\n            }\n            return this  // this就是api自己，return api后还能够再次调用api内的所有函数\n        },\n        find(selector) {\n            let array = []\n            for (let i = 0; i < elements.length; i++) {\n                array = array.concat(Array.from(elements[i].querySelectorAll(selector)))\n            }\n            // 旧api中包含了elements的数据，将旧api存入数组中传给新的api\n            array.oldApi = this  // 旧api\n            // return this   此时如果返回api，当api再次调用addClass时，改变的依然是elements第一次获取到的标签class值，而没改变find函数获取到的标签class值 \n            // return array  返回array，相当于把数组返回，函数不能够继续调用\n\n            // 因此，需要重新创建一个jquery构造出来的新api对象，并传入数组，此时elements就等于这个数组，\n            // 并且，新的jquery对象依然有addClass属性和find属性，再次调用，函数属性使用elements时，elements就等于find返回的array。\n            // 下面两行代码 === return jQuery(array)\n            const newApi = jQuery(array)\n            return newApi\n        },\n        // 遍历函数\n        each(fn) {\n            for (let i = 0; i < elements.length; i++) {\n                fn.call(null, elements[i], i)\n            }\n            return this\n        },\n        // 获取父级元素\n        parents() {\n            const array = []\n            this.each((node) => {\n                // indexof方法，能获取参数在数组中的索引，\n                // 如果数组中没有这个参数，则返回-1\n                if (array.indexOf(node.parentNode) < 0) {\n                    array.push(node.parentNode)\n                }\n            })\n            // 返回数组无法操作，所以返回一个新的api操作数组，新api中array等于elements\n            return jQuery(array)\n        },\n        // 获取子级元素\n        children() {\n            const array = []\n            // array.push(node.children[0],node.children[1],……node.children[n])\n            this.each((node) => { array.push(...node.children) })\n            // 返回数组无法操作，所以返回一个新的api操作数组，新api中array等于elements\n            return jQuery(array)\n        },\n        // 获取兄弟\n        siblings() {\n            const array = []\n            this.each((node) => {\n                // 获取上一个节点\n                array.push(node.previousSibling)\n                // 获取下一个节点\n                array.push(node.nextElementSibling)\n            })\n            console.log(array)\n        },\n        // 打印elements元素\n        print() {\n            console.log(elements)\n        },\n        // 新的api中的oldApi属性值等于数组中的oldApi\n        oldApi: selectorOrArray.oldApi,\n        // 使用新api调用back，返回旧的api\n        back() {\n            return this.oldApi\n        }\n    }\n    return api\n},\n\n\n\n\n    // jQuery('.test').addClass('red').find(\".child\").addClass(\"pink\")\n    // jQuery('.test').addClass('red').find(\".child\").addClass(\"pink\").back().addClass('a')\n\n    // let x = jQuery('.test').find('.child')\n    // x.each((x, y) => console.log(x, y))\n\n    // jQuery('.test').children().print()\n    $('.test').siblings()"],"names":[],"version":3,"file":"index.f5dc2189.js.map","sourceRoot":"/__parcel_source_root/"}